# Enhanced Dataloader Configuration for Robust Training - OPTIMIZED
# Optimized configuration based on improved bbox conversion logic

train_dataloader:
  dataset:
    transforms:
      ops:
        # ===== STEP 1: BASIC CLEANUP =====
        # Clean up bboxes first
        - {type: SanitizeBoundingBoxes, min_size: 1}
        
        # ===== STEP 2: STANDARD DETECTION AUGMENTATION =====
        # Apply IoU crop at original resolution (important)
        - {type: RandomZoomOut, side_range: [1.0, 1.4], fill: 0}
        - {type: RandomIoUCrop, p: 0.8}
        - {type: SanitizeBoundingBoxes, min_size: 1}  # cleanup after crop
        
        # ===== STEP 3: GEOMETRIC AUGMENTATION (원본 해상도에서) =====
        # Geometric transformation at original resolution - use GeometricAugmentationPipeline
        - {type: GeometricAugmentationPipeline, h_flip_p: 0.5, v_flip_p: 0.0, rotate_p: 0.5, rotate_limit: 30, fill: 0}
        - {type: SanitizeBoundingBoxes, min_size: 1}  # cleanup after geometric augmentation
        
        # ===== STEP 4: RESIZE (geometric aug 후) =====
        # Resize to target size after geometric augmentation
        - {type: Resize, size: [1280, 1280]}
        - {type: SanitizeBoundingBoxes, min_size: 1}  # cleanup after resize
        
        # ===== STEP 5: ROBUST PHOTOMETRIC AUGMENTATION =====
        # Color/lighting augmentation without affecting bboxes
        - {type: RandomPhotometricDistort, p: 0.8}  # 높은 확률로 color distortion
        - {type: RandomBrightnessContrast, 
           brightness_limit: [-0.3, 0.3], 
           contrast_limit: [-0.3, 0.3], 
           p: 0.7}  # strong brightness/contrast changes
        - {type: RandomGamma, gamma_limit: [70, 130], p: 0.5}  # gamma correction
        
        # ===== STEP 6: ROBUST NOISE & DEGRADATION =====
        # Noise/degradation without affecting bboxes
        - {type: GaussianNoise, var_limit: [5.0, 25.0], p: 0.5}  # noise
        - {type: JPEGCompression, quality_lower: 60, quality_upper: 95, p: 0.4}  # compression artifacts
        - {type: CLAHE, clip_limit: [1, 4], tile_grid_size: [8, 8], p: 0.3}  # histogram equalization
        
        # ===== STEP 7: ROBUST OCCLUSION & DROPOUT =====
        # Occlusion without affecting bboxes
        - {type: CoarseDropout, max_holes: 8, max_height: 48, max_width: 48, p: 0.4}  # random masking
        - {type: RandomErase, p: 0.3, scale: [0.02, 0.2], ratio: [0.3, 3.3], value: 'random'}  # random erase
        
        # ===== STEP 8: FINAL FORMAT CONVERSION =====
        # Final format conversion after all augmentations
        - {type: SanitizeBoundingBoxes, min_size: 1}  # final cleanup
        - {type: ConvertPILImage, dtype: 'float32', scale: True}  # convert image to tensor
        - {type: ConvertBoxes, fmt: 'cxcywh', normalize: True}  # bbox format + normalization
    
      policy:
        name: stop_epoch
        epoch: 4  # early stop for robust training
        ops: [
          'RandomZoomOut', 
          'RandomIoUCrop',
          'GeometricAugmentationPipeline',  # integrated geometric augmentation
          'RandomPhotometricDistort', 
          'RandomBrightnessContrast',
          'RandomGamma',
          'GaussianNoise',
          'JPEGCompression', 
          'CLAHE',
          'CoarseDropout',
          'RandomErase'
        ]
        
  collate_fn:
    type: BatchImageCollateFunction
    base_size: 1280
    base_size_repeat: 3
    stop_epoch: 72 # epoch in [72, ~) stop multiscales

  shuffle: True
  total_batch_size: 32 # 4 GPUs * 2 per GPU
  num_workers: 4  # reduced for stability


val_dataloader:
  dataset:
    transforms:
      ops:
        - {type: Resize, size: [1280, 1280], }
        - {type: ConvertPILImage, dtype: 'float32', scale: True}
  shuffle: False
  total_batch_size: 64 # 4 GPUs * 2 per GPU
  num_workers: 4 # reduced for stability
